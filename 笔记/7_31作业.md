##### 要求：
1、在namespace default中使用Deployment部署pod 3个运行nginx，使用service 端口映射到clusterIP的8080端口
2、在namespace devtest中 使用Statefulset部署pod 3个 运行PHP，使用service 的clusterIP访问
3、在namespace opstest中，使用Statefulset部署pod 1个运行mysql
访问nginx的service的clusterIP地址，可以打开index.php的测试页面，及mysql的链接测试
******
```shell
# 创建作业目录
mkdir lnmp
cd lnmp
# 编写nginx.yaml文件
vim nginx.yaml
###
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 80
###
# 验证
kubectl infopod default
```
![](https://gitee.com/zhaojiedong/img/raw/master/202407311557290.png)
```shell
# 编写php.yaml文件
vim php.yaml
###
apiVersion: v1
kind: Namespace
metadata:
  name: devtest
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: php
  namespace: devtest
spec:
  serviceName: php-service
  replicas: 3
  selector:
    matchLabels:
      app: php
  template:
    metadata:
      labels:
        app: php
    spec:
      containers:
      - name: php
        image: php:7.4-fpm
        ports:
        - containerPort: 9000
---
apiVersion: v1
kind: Service
metadata:
  name: php-service
  namespace: devtest
spec:
  selector:
    app: php
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9000
###
# 验证

```
![](https://gitee.com/zhaojiedong/img/raw/master/202407311558186.png)

```shell
# 编写mysql.yaml文件
vim mysql.yaml
###

###
```





















kubectl-infopod 脚本插件
替换或更改即可
```shell
#!/bin/bash
show_usage() {
    echo "使用方法:"
    echo "  kubectl infopod                     # 查询当前namespace的pods"
    echo "  kubectl infopod <pod_name>          # 查询匹配的pod"
    echo "  kubectl infopod <namespace_name>    # 查询指定namespace的pods"
    echo "  kubectl infopod ... -w              # 持续监视模式"
}

query_pods() {
    local query=$1
    local watch=$2
    local namespaces=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}')
    local watch_flag=""
    
    if [ "$watch" = "true" ]; then
        watch_flag="-w"
    fi
    
    # 检查是否是namespace
    if echo $namespaces | grep -w -q "$query"; then
        echo "在该namespace中的pod: $query"
        kubectl get pod -n "$query" $watch_flag -o custom-columns=NAME:.metadata.name,IP:.status.podIP,STATUS:.status.phase,NODE:.spec.nodeName,IMAGE:.spec.containers[0].image
    else
        # 在所有namespace中查找匹配的pod
        local found=false
        for ns in $namespaces; do
            if kubectl get pod -n "$ns" "$query" &>/dev/null; then
                echo "Pod found in namespace: $ns"
                kubectl get pod -n "$ns" "$query" $watch_flag -o custom-columns=NAME:.metadata.name,IP:.status.podIP,STATUS:.status.phase,NODE:.spec.nodeName,IMAGE:.spec.containers[0].image
                found=true
                break
            fi
        done
        
        if [ "$found" = false ]; then
            echo "没有任何匹配的pod: $query"
            show_usage
        fi
    fi
}

watch_mode=false
args=()

# 解析参数
for arg in "$@"; do
    if [ "$arg" = "-w" ]; then
        watch_mode=true
    else
        args+=("$arg")
    fi
done

if [ ${#args[@]} -eq 0 ]; then
    # 无参数，查询当前namespace的pods
    kubectl get pod $([[ "$watch_mode" = true ]] && echo "-w") -o custom-columns=NAME:.metadata.name,IP:.status.podIP,STATUS:.status.phase,NODE:.spec.nodeName,IMAGE:.spec.containers[0].image
elif [ ${#args[@]} -eq 1 ]; then
    # 有一个参数，查询匹配的pod或namespace
    query_pods "${args[0]}" "$watch_mode"
else
    # 参数不正确，显示使用方法
    show_usage
    exit 1
fi
```